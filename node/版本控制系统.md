https://elasticstack.blog.csdn.net/article/details/108810469


你存储在 Elasticsearch 中的每个文档都有一个关联的版本号。 该版本号是介于1和2 的 63-1 次方之间的正数。 首次为文档建立索引时，它的版本为1，你可以在响应中看到 Elasticsearch 返回。
无论是 index，update 还是 delete，Elasticsearch 都会将版本增加 1。该增加是原子的，并且保证在操作成功返回时会发生。

我们需要一种解决方案，该方案中潜在的两个用户可能试图同时更新同一文档。传统上，这将通过锁定来解决：在更新文档之前，人们将获得对其的锁定，进行更新并释放该锁定。锁定文档后，可以确保没有人可以更改文档。

在许多应用程序中，这还意味着，如果某人正在修改文档，则在修改完成之前，其他任何人都无法读取该文档。这种类型的锁定有效，但需要一定的代价。在高吞吐量系统的情况下，它有两个主要缺点：

在许多情况下，根本不需要它。如果做对了，碰撞很少发生。当然，它们会发生，但这仅适用于系统执行的部分操作。
锁定假定你实际上在乎。如果你只想呈现一个网页，即使系统知道它会在短时间内发生变化，也可以获取一些过时但一致的值，这可能很好。读取并不总是需要等待正在进行的写入完成。
Elasticsearch 是分布式的。创建，更新或删除文档时，必须将文档的新版本复制到群集中的其他节点。 Elasticsearch 也是异步和并发的，这意味着这些复制请求是并行发送的，并且可能不按顺序到达其目的地。 Elasticsearch 需要一种方法来确保文档的旧版本永远不会覆盖新版本。

为确保文档的较旧版本不会覆盖较新的版本，对文档执行的每项操作均由主分片分配一个序号，以协调更改。每次操作都会增加序列号，因此可以确保较新的操作具有比较旧的操作更高的序列号。然后，Elasticsearch 可以使用操作的序列号来确保分配给它的序列号较小的更改不会覆盖较新的文档版本。

我们可以看到一个叫做 _seq_no 及 _primary_term 的值。在每次的操作中，_seq_no 的值会自动增加

我们看到 version 的值增加 1，同时 _seq_no 的值也同时增加 1。

Elasticsearch 会跟踪上次操作的序列号 (_seq_no) 和主要术语 (_primary_term)，以更改其存储的每个文档。 序列号和主要术语在 GET API 的响应中的 _seq_no 和 _primary_term 字段中返回：


注意：通过设置 seq_no_primary_term parameter，Search API 可以为每个搜索命中返回 _seq_no 和 _primary_term。

序列号和主要术语唯一地标识更改。 通过记下返回的序列号和主要术语，可以确保仅在检索以来未对其进行任何其他更改的情况下才更改该文档。 这可以通过设置 index API，update API 或 delete API 的 if_seq_no 和 if_primary_term 参数来完成。

